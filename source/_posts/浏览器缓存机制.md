##### 缓存发展史：

HTTP/1.0提出Expires(过期时间)和Pragma给客户端设定资源的缓存策略，Pragma字段值为no-cache(RFC中规定Pragma有且仅有no-cache作为字段值)时，与Cache-Control: no-cache作用相同；**Expires用来启用缓存和定义缓存时间**，使用一个GMT(格林尼治时间)作为值(Expires为无效的日期格式时，等同于已经过期)。**如果Pragma和Expires同时存在，则起作用的会是Pragma**。

由于Expires所定义的缓存时间是相对服务器上的时间而言的，无法保证和客户端本地时间统一。HTTP/1.1增加Cache-Control(缓存控制)中的max-age替代Expires来定义缓存过期时间。若报文中同时出现了Pragma: no-cache、Expires和Cache-Control: max-age，优先级从高到低分别是Pragma: no-cache > Cache-Control: max-age > Expires。

上述首部字段能让客户端确认资源的缓存策略与过期时间，在下次请求该资源时**决定是否向服务器发送请求**，Last-Modified与Etag可以实现缓存文件是否更新的验证，提升缓存的复用率。

HTTP/1.1风格的Etag是对HTTP/1.0风格的Last-Modified的补充，两者没有优先级和替代性。

##### 如何判断资源采取的缓存策略：

1. Cache-Control: no-store：响应不会被缓存到任意的磁盘或者内存里，优先级高于Pragma: no-cache与Expires
2. Cache-Control: no-cache/Pragma: no-cache：客户端仍会缓存响应，只不过每次不会直接用缓存，而得先进行协商缓存，优先级高于Expires与Cache-Control: max-age
3. Cache-Control: max-age：客户端缓存响应，在指定时间内都200 from cache，优先级高于Expires

即缓存策略按照优先级排序共有三档：no-store，no-cache(协商缓存)，强缓存。

Pragma/Expires/Cache-Control/Last-Modified/Etag，响应头只包含Etag会启用协商缓存，只包含Last-Modified会启用强缓存。

##### 想让一个资源能缓存，有三种方式，按照解析优先级排序如下：

1. HTTP/1.1风格的**Cache-Control**响应头中的**max-age**，如Cache-Control: max-age=86400(以秒为单位)
2. HTTP/1.0风格的**Expires**响应头，如expires: Thu, 19 Nov 2020 02:40:03 GMT
3. **Last-Modified**响应头

```JavaScript
HTTP/2 200
Date: Wed, 27 Mar 2019 22:00:00 GMT
Last-Modified: Wed, 27 Mar 2019 12:00:00 GMT
```

这个响应，没有Cache-Control和Expires，浏览器就会用隐式的**启发式的(heuristic)缓存**，HTTP规范推荐的算法为Date响应头的时间减去Last-Modified的时间，得出的时长再除以10。

##### 如何判断缓存过期：

通过HTTP/1.0风格的**Expires: GMT**响应头和HTTP/1.1风格的**Cache-Control: max-age**响应头来判断资源缓存是否过期(强缓存阶段)。

如果没有过期，则200 from cache；过期则需要重新核对资源的缓存过期时间(协商缓存阶段)，可通过HTTP/1.0风格的**If-Modified-Since/Last-Modified**和HTTP/1.1风格的**If-None-Match/Etag**进行验证(RFC规定，如果ETag和Last-Modified都有，则必须一次性发送If-Modified-Since和If-None-Match给服务器，两者没有优先级)。

点击浏览器的后退前进按钮时，浏览器会尽量用本地缓存来重新打开页面(即使缓存已经过期)，只有Cache-Control: no-store导致硬盘上没有缓存才能解决。

##### 缓存过期后如何更新缓存：

在HTTP客户端(浏览器或者缓存服务器)上，如果某个URL对应的缓存过期了，客户端会再次向该URL发送一个条件请求(带有If-Modified-Since/If-None-Match请求头)，如果服务端(缓存服务器或者源站)返回的状态码是304(没有响应体)，则客户端会根据该304响应所包含的一些响应头(Date、Last-Modified、Cache-Control等)**重新计算出这条缓存的过期时间**，比如：

```JavaScript
HTTP/2 304
Cache-Control: max-age=86400
```

这样的304响应，就能让这条缓存重新续命一天；如果返回的状态码是200，则整条缓存会被新返回的响应体替换掉。

##### Cache-Control常见属性：

- max-age=86400(单位为秒)
- private：响应只能在私有缓存中被缓存，不能放在代理缓存上
- public：响应可以在代理缓存中被缓存
- no-cache：客户端仍会缓存响应，只不过每次不会直接用缓存，而得先进行协商缓存
- no-store：响应不会被缓存到任意的磁盘或者内存里

##### Etag对Last-Modified的补充：

1. 文件打开，未修改，保存后Last-Modified改变导致客户端不该更新的资源被更新
2. 文件打开，修改，迅速保存是无法判断的，If-Modified-Since能检查到的粒度是秒级的，Last-Modified不改变导致客户端该更新的资源未被更新
3. 某些服务器不能精确得到文件的最后修改时间

##### 浏览器行为对应缓存策略的区别：

- 输入URL+回车/点击书签访问：正常缓存策略，缓存未过期则200 from cache
- F5/点击工具栏中的刷新按钮/右键菜单重新加载：无论缓存是否过期，都需要发送一个条件请求(带有If-Modified-Since/If-None-Match请求头)
- Ctl+F5：无论缓存是否过期，彻底重拿一份新的资源过来