##### 脚本错误信息收集：

###### window.onerror：

- 要把window.onerror这个代码块分离出去，并且比其他脚本先执行即可捕捉到语法错误（冒泡阶段处理错误）
- 无论是异步（setTimeout等）还是非异步都能捕获到
- 由于网络请求异常事件不会冒泡，需要在捕获阶段进行处理，window.addEventListener('error', function(){}, true)；**不能捕获promise的错误信息**
- 跨域资源需要专门处理，script脚本设置为：crossorigin="anonymous"；同时服务器添加 Access-Control-Allow-Origin 以指定允许哪些域的请求访问
- window.onerror函数消化错误，需要显示返回true，以保证错误不会向上抛出，控制台也就不会看到一堆错误提示

```JavaScript
 window.onerror = function (error) {
    console.log(error);
    return true //此时不会在控制台显示浏览器自带的红色错误提示
}
var a = b
//这里出错，进行console.log(error)，error是字符串
//Uncaught ReferenceError: b is not defined
```

###### window.addEventListener('error', function(){}, true)

- 网络加载错误是不会进行事件冒泡的，需要在网络加载错误捕获阶段进行处理

```HTML
<script>
    window.addEventListener('error', function (error) {
        console.log(error);
        error.preventDefault() //此时不会在控制台显示浏览器自带的红色错误提示
        //如果使用return true替代error.preventDefault()还是会在控制台显示浏览器自带的红色错误提示
    }, true)
</script>
<script src="./JavaScript.js"></script>
<link rel="stylesheet" href="./style.css">
<img src="./image.jpg" alt="">
<script>
    //网络加载错误，console.log(error)，error是Event事件对象
    //可通过Event事件对象中的target属性得知资源详情
</script>
```

- 无论是异步（setTimeout等）还是非异步都能捕获到；可以拿到出错的信息，堆栈，出错的文件、行号、列号

```JavaScript
window.addEventListener('error', function (error) {
    console.log(error);
    return true
}, true)
setTimeout(() => {
    var a = b
}, 1000)
//console.log(error)，error是ErrorEvent事件对象
//以下是ErrorEvent对象部分信息展示
ErrorEvent = {
    message: "Uncaught ReferenceError: b is not defined",
    filename: "file:///C:/Users/Air/Desktop/index.html",
    lineno: 14,
    colno: 21,
    type: "error"
}
```

###### try catch：

- 无法捕捉到语法错误，只能捕捉运行时错误
- 在代码中手动添加或者通过自动化工具经AST对每个函数添加try catch
- try catch只能捕获同步代码的异常，对回调、setTimeout、promise等无能为力
- 使用try catch，我们可以保证页面不崩溃，并对错误进行兜底处理，这是一个非常好的习惯；但是代码入侵性强

###### Promise错误处理：

- 当一个promise被reject，就会引发catch：1. 调用reject(reason) 2. 在promise构造器函数中代码出错，如“Uncaught ReferenceError: b is not defined” 3. 明确用throw抛出错误 4. 嵌套的promise也会引发reject。内层promise造成的reject状态会冒泡，造成顶层promise也reject
- catch会检查promise链上位于它之前的每个地方(then和其他异步操作)；如果它之前还有另一个catch，则从那个catch之后的位置开始

```JavaScript
asyncTask()
    .then()
    .then()
    .then()
    .catch() //覆盖asyncTask和3个then
asyncTask()
    .catch() //只覆盖asyncTask
    .then()
    .then()
    .catch() //覆盖了2个then
```

- 和then一样，catch也会返回一个可链式操作的新promise对象
- promise实例的then方法中的第二个onRejected函数可以处理错误；写Promise的时候最后写上catch函数也可以处理错误。推荐catch函数。
- 在没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。当promise被reject并且错误信息没有被处理的时候，会抛出unhandledrejection，这个错误不会被window.onerror和addEventListener("error")所监听到

```JavaScript
window.addEventListener("unhandledrejection",  error => {
   console.log(error.reason)
   error.preventDefault()
})
```

###### 框架的错误处理：

框架会有相应的函数或者API来进行错误处理，如果没有配置，那么捕获到的错误会以 console.error 的方式输出。因此可以劫持 console.error，捕获框架中的错误并做出处理。

##### 错误信息上报：

###### 采用单独域名：

- 使用单独域名，可以防止对主业务服务器的压力，能够避免日志相关处理逻辑和数据在主业务服务器的堆积
- 另外，很多浏览器对同一个域名的请求量有并发数的限制（队头阻塞），单独域名能够充分利用现代浏览器的并发设置

###### 独立域名的跨域问题：

对于单独的日志域名，肯定会涉及跨域问题。我们经常发现页面使用「构造空的 Image 对象的方式」进行数据上报。原因是请求图片并不涉及跨域的问题：我们可以将数据进行序列化，作为 URL 参数传递

###### 何时上报数据：

- 页面加载和重新刷新
- 页面切换路由
- 页面所在的 Tab 标签重新变得可见
- 页面关闭

###### 单页应用上报：

如果切换路由是通过改变 hash 值来实现的，那么只需要监听 hashchange 事件，如果是通过 history API 来改变 URL，那么需要使用 pushState 和 replaceState 事件。当然一劳永逸的做法是进行 monkey patch，结合发布订阅模式，为相关事件的触发添加处理：

```JavaScript
const patchMethod = type => () => {
    const result = history[type].apply(this, arguments)
    const event = new Event(type)
    event.arguments = arguments
    window.dispatchEvent(event)
    return result
}
history.pushState = patchMethod('pushState')
history.replaceState = patchMethod('replaceState')
//添加订阅函数，进行上报
window.addEventListener('replaceState', e => {
   // report...
})
window.addEventListener('pushState', e => {
   // report...
})
```

###### navigator.sendBeacon：

解决「页离开时的请求发送」问题的。它的几个特点决定了对应问题的解决方案：

- 它的行为是异步的，也就是说请求的发送不会阻塞向下一个页面的跳转，因此可以保证跳转的流畅度；
- 它在不受到极端「数据 size 和队列总数」的限制下，优先返回 true 以保证请求的发送成功。

目前 Google Analytics 使用 navigator.sendBeacon 来上报数据。

 Google Analytics 通过动态创建 img 标签，在 img.src 中拼接 URL 的方式发送请求，不存在跨域限制。如果 URL 太长，就会采用 sendBeacon 的方式发送请求，如果 sendBeacon 方法不兼容，则发送 AJAX post 同步请求。
 
######  上报行为优化：

- 设置采集率：每次上报前进行Math.random()来判定是否上报
- 如果用户一直触发错误，相同的错误内容会不停上报，这时可以考虑是否需要做一个短时间滤重（节流）
- 通过配置化，减少业务接入成本